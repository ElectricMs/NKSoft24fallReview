# 计网复习

计网复习 202412 2211030

- 选择（10道题，20分） 
- 填空（30空，30分）
- 简答（4道题，50分）



## 引言

**层次栈：**为降低网络设计的复杂性，网络使用层次结构的协议栈，每一层都使用其下一层所提供的服务，并为上层提供自己的服务

**对等实体：**不同机器上构成相应层次的实体成为对等实体

**接口：**在每一对相邻层次之间的是接口；接口定义了下层向上层提供哪些服务原语

**网络体系结构：**层和协议的集合为网络体系结构，一个特定的系统所使用的一组协议，即每层的协议，称为协议栈

**六个核心服务原语（以面向连接服务为例）：**

（1）连接请求 （2）接受响应 （3）请求数据 （4）应答 （5）请求断开 （6）断开连接

**服务与协议的关系**

- 协议是“水平”的，服务是“垂直”的
- 实体使用协议来实现其定义的服务
- 上层实体通过接口使用下层实体的服务

### OSI参考模型

- 物理层：定义如何在信道上传输0、1：Bits on the wire

- 数据链路层： 实现相邻（Neighboring）网络实体间的数据传输 • 成帧（Framing）：从物理层的比特流中提取出完整的帧 • 错误检测与纠正：为提供可靠数据通信提供可能

- 网络层：将数据包跨越网络从源设备发送到目的设备（host to host） • 路由（Routing）：在网络中选取从源端到目的端转发路径， 常常会根据网络可达性动态选取最佳路径，也可以使用静态路由

- 传输层： 将数据从源端口发送到目的端口（进程到进程）
- 会话层
- 表示层
- 应用层

### TCP/IP参考模型

端对端原则：采用聪明终端&简单网络，由端系统负责丢失恢复等，简单的网络大大提升了可扩展性

- 网络接口层
- 互联网层
- 传输层
- 应用层

### 比较

**7层模型与4层模型**

- TCP/IP模型的网络接口层定义主机与传输线路之间的接口，描述了链路为无连接的互联网层必须提供的基本功能
- TCP/IP模型的互联网层、传输层与OSI模型的网络层、传输层大致对应
- TCP/IP模型的应用层包含了OSI模型的表示层与会话层

**基本设计思想：通用性与实用性**

- OSI：先有模型后设计协议，不局限于特定协议，明确了服务、协议、接口等概念，更具通用性
- TCP/IP模型：仅仅是对已有协议的描述

**无连接与面向连接**

- OSI模型网络层能够支持无连接和面向连接通信
- TCP/IP模型的网络层仅支持无连接通信（IP）

**计算机网络度量单位**

• 比特率 • 带宽 • 包转发率 • 时延 • 时延带宽积 • 吞吐量 • 丢包率 • 利用率 • 往返时间RTT • 时延抖动



## 物理层（不考）

### 基本概念

不是连接计算机的具体物理设备，不是负责信号传输的具体物理媒体

**功能：如何在连接各计算机的传输媒体上传输数据比特流**

数据链路层将数据比特流传送给物理层 

物理层将比特流按照传输媒体的需要进行编码

然后将信号通过传输媒体传输到下一个节点的物理层

### 传输介质



###  多路复用技术

- 频分复用
- 时分复用与统计时分复用 
- 波分复用 
- 码分复用



## 数据链路层

- *了解数据链路层在网络体系结构中的位置及基本功能和服务*
- ***掌握差错检测和纠正的基本原理和典型的编码方法（核心内容）***
- ***掌握无错信道和有错信道上停等协议的设计和实现方法（核心内容）***
- *理解停等协议的性能问题及滑动窗口协议的基本思想*
- ***掌握回退N和选择重传两种典型滑动窗口协议的工作机制（核心内容）***
- *了解点到点链路层协议PPP与PPPoE*

### 数据链路层的设计问题

**三个功能：**

- ==成帧==（Framing） ：将比特流划分成“帧”的主要目的是为了检测和纠正物理层在比特传输中可能出现的错误，数据链路层功能需借助“帧”的各个域来实现
- ==差错控制==（Error Control）：处理传输中出现的差错，如位错误、丢失等
- ==流量控制==（Flow Control）：确保发送方的发送速率，不大于接收方的处理速率，避免接收缓冲区溢出



### 差错检测和纠正

码字(code word)：一个包含m个数据位和r个校验位的n位单元，描述为(n, m) 码，n=m+r 

码率(code rate)：码字中不含冗余部分所占的比例，可以用m/n表示

海明距离(Hamming distance)：两个码字之间不同对应比特的数目

- 例：0000000000 与0000011111的海明距离为5
- 如果两个码字的海明距离为d，则需要d个单比特错就可以把一个码字转换成另一 个码字
- 为了检查出d个错（比特错），可以使用海明距离为d+1 的编码 
- 为了纠正d个错，可以使用海明距离为2d+1 的编码

#### 常用的检错码

**奇偶检验(Parity Check)：**1位奇偶校验是最简单、最基础的检错码。偶校验：保证1的个数为偶数个；奇校验：保证1的个数为奇数个。

**校验和(Checksum)：**主要用于TCP/IP体系中的网络层和传输层。发送方：进行16 位二进制补 码求和运算，计算结果取反， 随数据一同发送。

**循环冗余校验(Cyclic Redundancy Check，CRC)：**数据链路层广泛使用的校验方法。![CRC](.\img\CRC.png)

#### 典型纠错码-海明码

![HammingCode](.\img\HammingCode.png)



### 基本的数据链路层协议

**乌托邦式单工协议** 

**无错信道单工停止-等待协议：**

假设不会出错，半双工通道，会溢出

- 发送方发送一帧后暂停，等待确认 （Acknowldgement）到达后发送下一帧
- 接收方完成接收后，回复确认接收
- 确认帧的内容是不重要的：哑帧（dummy frame）

**有错信道单工停止-等待协议：**

会出错，半双工通道，会溢出。发送方发出一帧后收到确认才会发下一帧

- 发送方增加一个**计时器(timer)**，如果经过一段时间没有收到确认，发送方将超时，于是再次发送该帧
- **序号（SEQ：sequence number）：**接收方需要确认到达的帧是否第一次发来的新帧 ；让发送方在发送的帧的头部放一个序号，接收方可以检查它所收到的帧序号，由此判断这是个新帧还是应该被丢弃的重复帧。
- **序号所需要的最小位数（bits）：**序号需要区分当前帧（序号m）和它的直接后续帧（序号m+1）， 1bit序号(0或1)就足以满足要求。



### 滑动窗口协议

- 窗口机制：发送方和接收方都具有一定容量的缓冲区（即窗口），发送端在收到确认之前可以发送多个帧
- 累计确认：不必对收到的分组逐个发送确认，而是对按序到达的最后一个分组发送确认

#### 回退N协议（回退1协议？）

**出错全部重发**：当接收端收到一个**出错帧或乱序帧**时，丢弃所有的后继帧，并且不为这些帧发送确认； 发送端超时后，重传所有未被确认的帧。

该策略对应==接收窗口为1==的情况，即只能按顺序接收帧。

#### 选择重传协议

若发送方发出连续的若干帧后，收到对其中某一帧的否认帧，或某一帧的定时器超时，则只重传该出错帧或计时器超时的数据帧

该策略对应==接收窗口大于1==的情况，即暂存接收窗口中序号在出错帧之后的数据帧

**基本原理：** 

- 在发送过程中，如果一个数据帧计时器超时，就认为该帧丢失或者被破坏； 接收端只把出错的的帧丢弃，其后面的数据帧保存在缓存中，并向发送端回复NAK；发送端接收到NAK时，只重传出错的帧
- 如果落在窗口内的帧从未接受过，那么存储起来，等比它序列号小的所有帧都正确接收后，按次序交付给网络层
- 接收端收到的数据包的顺序可能和发送的数据包顺序不一样，因此在数据包里必须含有顺序号来帮助接收端进行排序。





## 介质访问子层MAC

*两种ALOHA协议、CSMA工作原理、经典以太网的拓扑和帧结构*

*交换式以太网的特征、数据链路层交换的原理、MAC地址表的维护*

### 信道分配问题

常见的局域网拓扑：总线拓扑、星型拓扑、环型拓扑

共同点：共享一根信道

### 多路访问协议

#### 随机访问

**纯ALOHA协议：**想发就发，==随时可能冲突==，冲突的帧完全破坏，破坏了的帧要重传

**分隙ALOHA（Slotted ALOHA）协议：**把时间分成时隙（时槽），时隙的长度对应一帧的传输时间，帧的发送必须在时隙的起点，==冲突只发生在时隙的起点==

**载波侦听多路访问协议（Carrier Sense Multiple Access，CSMA）：**

- **非持续式CSMA：**经侦听，如果介质空闲，开始发送；==如果介质忙，则等待一个随机分布的时间==，然后尝试前面步骤。
- **CSMA/CD  （1-持续）：**①经侦听，如介质空闲，则发送。②如介质忙，持续侦听，一旦空闲立即发送。③如果发生冲突，等待一个随机分布的时间再重复步骤①。以太网采用了CSMA/CD。
- **p-持续式CSMA：**①经侦听，如介质空闲，那么==以p的概率发送，以(1–p)的概率延迟一个时间单元发送== • ②如介质忙，持续侦听，一旦空闲重复① • ③如果发送已推迟一个时间单元，再重复步骤①

#### 受控访问

- 位图协议
- 二进制倒计数
- 令牌

#### 有限竞争

- 自适应树搜索协议（Adaptive Tree Walk Protocol ）

### 以太网

**不同以太网的带宽**

1. 经典以太网：10Mbps
2. 快速以太网：100Mbps
3. 千兆以太网：1000Mbps
4. 万兆以太网：10Gbps

**MAC帧格式**

![MAC](.\img\MAC.png)



### 数据链路层交换

==三种操作：转发、过滤、泛洪==

MAC地址表的构建-逆向学习源地址：

- 增加表项：帧的源地址对应的项不在表中，增加一个新表项（源地址、入境端口、帧到达时间）
- 删除表项：老化时间到期
- 更新表项：帧的源地址在表中，重置老化时间

两种目的地址的帧，需要泛洪（Flooding）：

- 广播帧：目的地址为FF-FF-FF-FF-FF-FF的数据帧
- 未知单播帧：目的地址不在MAC地址转发表中的单播数据帧





## 网络层

*无连接和面向连接服务*

*Internet网络层协议：IPv4/IPv6, ICMP, DHCP, NAT, ARP*

*链路状态、距离矢量等路由算法*

*Internet路由协议：OSPF、RIP、BGP*

### 网络层服务

路由器层次最高到网络层

网络层的两个关键功能：路由、转发

- 发送端：将传输层数据单元封装在数据包中
- 接收端：解析接收的数据包中，取出传输层数据单元，交付给传输层
- 路由器：检查数据包首部，转发数据包

### Internet网际协议

#### IPv4

![IPv4](.\img\IPv4.png)

**数据包分片：**

- MTU（Maximum Transmission Unit）, 最大传输单元
- 标志位的DF和MF
- 重组策略：目的端重组（途中重组实施难度太大）
- 片偏移：字节数/8

数据包长度大于传输链路的MTU的问题，通过分片机制解决：标识、标志、片偏移

防止循环转发浪费网络资源（路由错误、设备故障…），通过跳数限制解决：生存时间TTL

IP报头错误导致无效传输，通过头部机校验解决：首部校验和

#### IP地址与子网

网络号+主机号

主机位全0，子网地址；主机位全1，广播地址

**分类：**

- A类：1.0.0.0~127. 255.255.255
- B类：128.0.0.0~191.255.255.255
- C类：192.0.0.0~223.255.255.255

**无类域间路由 CIDR（Classless Inter-Domain Routing ）：**

- 将32位的IP地址划分为前后两个部分，并采用斜线记法，即在IP地址后加 上“/”，然后再写上网络前缀所占位数
-  一个CIDR 地址块可以表示很多地址，这种地址的聚合常称为路由聚合 （route aggregation），也称为构成超网 (supernet)
- 聚合技术在Internet中大量使用，它允许前缀重叠，数据包按具体路由的方向发送，即具有最少IP地址的最长匹配前缀
- 最长前缀匹配（Longest prefix match）：IP地址与IP前缀匹配时，总是选取子网掩码最长的匹配项

IP 地址放在IP 数据包的首部，而硬件地址则放在MAC 帧的首部

==IP数据包经过不同链路时，IP 数据包中封装的IP地址不发生改变，而Mac帧中的硬件地址是发生改变的==

#### ARP

地址解析协议（Address Resolution Protocol,缩写ARP）

仔细看下

- A已知B的IP地址，需要获得B的MAC地址（物理地址）
- 如果A的ARP表中缓存有B的IP地址与MAC地址的映射关系，则直接从ARP表获取
- 如果A的ARP表中未缓存有B的IP地址与MAC地址的映射关系，则A广播包含B的IP地址的ARP query分组，在局域网上的所有节点都可以接收到ARP query
- B接收到ARP query分组后，将自己的MAC地址发送给A，A在ARP表中缓存B的IP地址和MAC地址的映射关系，超时删除

#### NAT

 网络地址转换(NAT)用于解决IPv4地址不足的问题，是一种将私有（保留）地址转化为公有IP地址的转换技术

- 出数据包：外出数据包用NAT IP地址(全局), 新port #替代 源IP地址(私有), port #
- NAT转换表：每个(源IP地址, port #)到(NAT IP地址, 新port #) 映射项
- 入数据包：对每个入数据包的地址字段用存储在NAT表中的(源IP地址, port #)替代对应的(NAT IP地址, 新port #)

NAT根据不同的IP上层协议进行NAT表项管理（TCP，UDP，ICMP）

传输层TCP/UDP拥有16-bit 端口号字段，所以一个WAN侧地址可支持60,000个并行连接

#### DHCP

DHCP (Dynamic Host Configuration Protocol)：动态主机配置协议

工作模式：客服/服务器模式（C/S ），基于UDP 工作，服务器运行在67 号端口，客户端运行在68 号端口，==一直是广播==。

- DHCP 客户从UDP端口68以广播形式向服务器发送发现报文（ DHCPDISCOVER） 
- DHCP 服务器以广播形式发出提供报文（DHCPOFFER）
- DHCP 客户从多个DHCP服务器中选择一个，并向其以广播形式发送 DHCP请求报文（DHCPREQUEST）
- 被选择的DHCP服务器以广播形式发送确认报文（DHCPACK）

![DHCP](.\img\DHCP.png)

#### ICMP

ICMP（Internet Control Message Protocol，互联网控制报文协议）主要用于在IP网络中传递控制信息和错误报告，携带在 IP 数据包中，IP上层协议号为1。

- ICMP 差错报告报文 - 终点不可达：不可达主机、不可达网络，无效端口、协议
- ICMP 询问报文 - 回送请求/回答(ping使用)
- PING 使用了ICMP 回送请求与回送回答报文
- Traceroute向目的地发送一系列UDP段，不断增大RTT

### 路由算法

#### 优化原则

**汇集树(Sink Tree)：**所有的源节点到一个指定目标节点的最优路径的集合构成一棵以目标节点为根的树，不一定唯一。

#### 最短路径算法

**Dijkstra算法：**基于贪心策略，逐步选择当前已知距离最近但尚未处理的节点，并通过这个节点更新其邻居的距离。

算法维护两个集合：一个包含已经确定最短路径的节点（S），另一个包含尚未确定最短路径的节点（U）。每次迭代中，算法都会从未处理的节点集合U中选择具有最小临时距离的节点v加入集合S，并更新与v相邻的所有节点的距离。

#### 距离向量路由

**Bellman-Ford 方程**

对于一个有向加权图 G*=(*V*,*E*)，其中 V* 是顶点集合，*E* 是边集合，假设我们有一个源节点 s*∈*V*。设 d*(*u*) 表示从源节点 *s* 到节点 *u* 的最短路径估计值，而 )*w*(*u*,*v*) 表示边 (*u*,*v*)∈*E* 的权重。那么，Bellman-Ford方程可以表示为：

`d(v)=min⁡(d(v),d(u)+w(u,v))`

这里 *u* 是 *v* 的所有前驱节点之一。换句话说，对于每一条边(*u*,*v*)，如果通过 *u* 到达 *v* 的路径比当前已知的最佳路径更短，则更新 *v* 的最短路径估计。

**距离向量（Distance Vector）算法基本思想：** 

- 每个节点周期性地向邻居发送它自己到某些节点的距离向量；
- 当节点𝑥接收到来自邻居的新DV估计，它使用B-F方程更新其自己的距离向量

**距离向量算法特点：**迭代的、分布式的

- 每次本地迭代由下列引起：本地链路费用改变、邻居更新报文
- 分布式：各节点依次计算，相互依赖

**距离向量路由（p187）**

- 路由器启动时初始化自己的路由表，包含所有直接相连的网络路径，距离均为0
- 路由器周期性地向其相邻路由器广播自己知道的路由信息，相邻路由器可以根据收到的路由信息修改和刷新自己的路由表
- 路由器经过若干次更新后，最终都会知道到达所有网络的最短距离，所有的路由器都得到正确的路由选择信息时网络进入“收敛”（convergence）状态

**计数到无穷问题**

- 好消息传播快，坏消息传播慢，是距离向量路由的一个主要缺点
- 需要多次迭代直到计数到16才能发现不可达

#### 链路状态路由

思路就是每个节点收集信息，各自构造图，计算最短路径

1. 发现邻居，了解他们的网络地址
2. 设置到每个邻居的成本度量（通过某种标准/算法衡量）
3. 构造**链路状态分组**（link state packet，LSP），分组中包含刚收到的所有信息（包含发送方标识、序列号、年龄、邻居列表）
4. 将LSP分组发送给其他的路由器
5. 计算到其他路由器的最短路径（通过Dijkstra算法）==要会画图P200==

**与距离向量路由的比较**

- 网络状态信息交换的范围：DV:邻居间交换；LS:全网扩散
- 网络状态信息的可靠性：DV:部分道听途说；LS:自己测量
- 健壮性：DV:计算结果传递，健壮性差；LS: 各自计算，健壮性好
- 收敛速度：DV:  慢，可能有计数到无穷问题；LS:  快

### Internet路由协议

==OSPF基于链路状态路由的原理，RIP基于距离向量路由的原理==

#### OSPF

OSPF（Open Shortest Path First）开放最短路径优先协议

- 向本自治系统中所有路由器洪泛信息
- 发送的信息就是与本路由器相邻的所有路由器的链路状态
- 只有==当链路状态发生变化时==路由器才用洪泛法发送此信息

OSPF支持将一组网段组合在一起，称为一个**区域**。使用层次结构的区域划分，上层的区域叫做主干区域，其他区域都必须与主干区域相连，非主干区域之间不允许直接发布区域间路由信息。路由器分为内部路由器、区域边界路由器、自治系统边界路由器。

#### RIP

路由选择协议RIP（Routing Information Protocol）是基于距离矢量算法的协议

- 使用跳数衡量到达目的网络的距离，认为一个好的路由就是它通过的路由器的数目少，即“距离短”
- 仅和相邻路由器交换信息，交换的内容是自己的路由表
- 周期性更新：30s

#### BGP

边界网关协议BGP (Border Gateway Protocol) ，是目前互联网中唯一实际运行的自治域间的路由协议，分为==eBGP（从相邻的AS获得网络可达信息）和iBGP（将网络可达信息传播给AS内的路由器）==，基于网络可达信息和策略决定到其他网络的“最优”路由。

- BGP会话：两个BGP路由器通过TCP连接交换BGP报文，通告到不同网络前缀的路径，即路径向量协议
- 路径通告原理，P196
- 在 BGP 刚刚运行时，BGP 的邻站交换整个的 BGP 路由表；以后只需要在发生变化时更新有变化的部分





## 传输层

网络层：主机到主机；传输层：进程到进程

套接字标识与端口号：端口号是套接字标识的一部分，端口号是一个16比特的数

### UDP

UDP套接字使用<IP地址, 端口号>二元组进行标识

<目的IP地址，目的端口号> 相同的UDP报文段被交付给同一个套接字，与<源IP地址，源端口号> 无关

报文段中的<源IP地址，源端口号> 被接收进程用来发送响应报文

#### 报头与校验和

![UDP](.\img\UDP.png)

这个UDP的结构也要记一下

报文长度：包含首部和数据部分，不算伪头长度

UDP的协议号：17

#### Socket编程

服务端：

```python
import socket

server_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
server_socket.bind(('localhost', 10001))

while True:
    data, addr = server_socket.recvfrom(1024)  # 接收数据和客户端地址
    message = data.decode('utf-8')
    print(f'收到消息: {message} 来自 {addr}')
    
    if message:
        response = f'Welcome {addr[0]}'
        print(f'发送回复: {response}')
        server_socket.sendto(response.encode('utf-8'), addr)
```

客户端：

```python
import socket

client_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
message = 'hello'  # 请替换为实际的姓名和学号

with client_socket:
    sent = client_socket.sendto(message.encode('utf-8'), ('localhost', 10001))
    data, addr = client_socket.recvfrom(1024)
    response = data.decode('utf-8')
    print(f'收到回复: {response}')
    client_socket.close()
```



### TCP

**监听套接字：**

- 服务器平时在监听套接字上等待客户的连接请求，该套接字具有众所周知的端口号

**连接套接字：**

- 服务器在收到客户的连接请求后，创建一个连接套接字，使用临时分配的端口号
- 服务器同时创建一个新的进程，在该连接套接字上服务该客户；每个连接套接字只与唯一一个客户通信
- 连接套接字需要使用<源IP地址，目的IP地址，源端口号，目的端口号>四元组进行标 识，服务器使用该四元组将TCP报文段交付到正确的连接套接字

#### 报文段结构

![TCP](.\img\TCP.png)

#### 可靠数据传输

**发送方：**

- 收到应用数据：
  - 创建并发送TCP报文段
  - 若当前没有定时器在运行（没有已发送、未确认的报文段），启动定时器
- 超时：
  - 重传包含最小序号的、未确认的报文段（仅对最早未确认的报文段使用一个重传定时器）
  - 重启定时器
- 收到ACK：
  - 如果确认序号大于基序号（已发送未确认的最小序号）：
    - 推进发送窗口（更新基序号），如果发送窗口中还有未确认的报文段，启动定时器，否则终止定时器

只使用一个定时器，避免了超时设置过小时重发大量报文段；利用流水式发送和累积确认，可以避免重发某些丢失了ACK的报文段

**接收方：**

- 收到期待的报文段：发送更新的确认序号
- 其它情况：重复当前的确认序号

为减小通信量，TCP允许接收端推迟确认：接收端可以在收到若干个报文段后，发送一个累积确认的报文段（推迟确认的时间最多为500ms；接收方至少每隔一个报文段使用正常方式进行确认）

| 接收端事件                                                  | 接收端动作                                                   |
| ----------------------------------------------------------- | :----------------------------------------------------------- |
| 收到一个期待的报文段，且之前的 报文段均已发送过确认         | 推迟发送确认，在500ms时间内若无下 一个报文段到来，发送确认   |
| 收到一个期待的报文段，且前一个 报文段被推迟确认             | 立即发送确认（估计RTT的需要）                                |
| 收到一个失序的报文段（序号大于 期待的序号），检测到序号间隙 | 立即发送确认（快速重传的需要），重 复当前的确认序号          |
| 收到部分或全部填充间隙的报文段                              | 若报文段始于间隙的低端，立即发送确 认（推进发送窗口），更新确认序号 |

**快速重传**

- 原理：发送方可利用重复ACK检测报文段丢失
- 发送方通常连续发送许多报文段，若仅有个别报文段丢失，发送方将收到多个重复序号的ACK
- TCP协议规定：当发送方收到对同一序号的==3次重复确认==时，立即重发包含该序号的报文段

#### 流量控制

接收端有一个接收缓存，TCP将收到的数据放入接收缓存，应用进程从接收缓存中读数据；发送端TCP通过调节发送速率，不使接收端缓存溢出而实现流量控制

**为什么回退N、选择重传和UDP不需要流量控制：**

- 回退N协议和选择重传协议均假设正确、按序到达的分组被立即交付给上层 ，其占用的缓冲区被立即释放； 发送方根据确认序号即可知道哪些分组已被移出接收窗口，接收窗口还可以接受多少分组（再回去看看，掌握三个方案的区别和优缺点）
- UDP不保证交付：接收端UDP将收到的报文载荷放入接收缓存，当应用进程消费数据不够快时，接收缓存溢出，报文数据丢失，UDP不负责任

**非零窗口通告**

- 发送方收到“零窗口通告”后，可以发送“零窗口探测”报文段
- 发送端收到零窗口通告时，启动一个坚持定时器；定时器超时后，发送端发送一个零窗口探测报文段（序号为上一 个段中最后一个字节的序号）
- 从而接收方可以发送包含接收窗口的响应报文段
- 若发送端仍收到零窗口通告，重新启动坚持定时器

**糊涂窗口综合症**

当数据的发送速度很快，而消费速度很慢时，零窗口探测的简单实现带来以下问题：

- 接收方不断发送微小窗口通告
- 发送方不断发送很小的数据分组
- 大量带宽被浪费

**接收方启发式策略**

- 通告零窗口之后，仅当窗口大小显著增加之后才发送更新的窗口通告
- 什么是显著增加：窗口大小达到==缓存空间的一半或者一个MSS==，取两者的较小值
- 当窗口大小不满足以上策略时，推迟发送确认（但最多推迟500ms，且至少每隔一个报文段使用正常方式进行确认），寄希望于推迟间隔内有更多数据被消费

**发送方启发式策略，基于Nagle算法**

- 在新建连接上，当应用数据到来时，组成一个TCP段发送（哪怕只有一个字节）
- 在收到确认之前，后续到来的数据放在发送缓存中
- 当数据量达到==一个MSS或上一次传输的确认到来==（取两者的较小时间），用一个TCP段将缓存的字节全部发走

**小结**

TCP接收端：

- 使用显式的窗口通告，告知发送方可用的缓存空间大小
- 在接收窗口较小时，推迟发送确认
- 仅当接收窗口显著增加时，通告新的窗口大小

TCP发送端：

- 使用Nagle算法确定发送时机
- 使用接收窗口限制发送的数据量，已发送未确认的字节数不超过接收窗口的大小

#### 连接管理

![TCP_Connect](.\img\TCP_Connect.png)

- 客户TCP发送SYN报文段（SYN=1, ACK=0），==给出客户选择的起始序号==，不包含数据
- 服务器TCP发送SYNACK报文段（SYN=ACK=1）（服务器端分配缓存和变量），==给出服务器选择的起始序号==，确认客户的起始序号，不包含数据
- 客户发送ACK报文段（SYN=0，ACK=1）（客户端分配缓存和变量），确认服务器的起始序号，可能包含数据

![TCP_Disconnect](.\img\TCP_Disconnect.png)

上图中关闭连接的Seq不对，注意一下

中止时要等待2MSL（Maximum Segment Lifetime）的原因：如果最后一个ACK服务端没有收到，服务端会重发FIN，这时会要求客户端重传ACK。



#### 拥塞控制

发送方利用丢包事件（重传定时器超时或发送端收到3个重复的ACK）感知拥塞

**拥塞窗口的调节策略：AIMD**

- 乘性减（Multiplicative Decrease）：发送方检测到丢包后，将cwnd的大小减半（但不能小于一个MSS）
- 加性增（Additive Increase）：若无丢包，每经过一个RTT，将cwnd增大 一个MSS，直到检测到丢包

**慢启动**

- 每收到一个ACK段，cwnd增加一个MSS，相当于每经过一个RTT，将cwnd加倍
- 只要发送窗口允许，发送端可以立即发送下一个报文段
- 在早期的TCP实现中，当一个连接建立后，发送方会立即按照接收窗口的大小尽可能多地发送数据，因此这个策略显得启动较慢

**区分不同的丢包事件**

- 收到3个重复的ACK：
  - 设置ssthresh (slow start  threshold) =cwnd/2
  - 将cwnd降至ssthresh+3
  - 使用AIMD调节cwnd
- 超时：
  - 设置ssthresh =cwnd/2
  - cwnd=1MSS
  - 使用慢启动增大cwnd至ssthresh
  - 使用AIMD调节cwnd

![TCP_Congestion_Control](.\img\TCP_Congestion_Control.png)

#### Socket编程

服务端：

```python
import socket

server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server_socket.bind(('localhost', 10000))
server_socket.listen(1)

while True:
    # 当有客户端连接时，accept()方法会返回一个新的套接字对象client_socket和客户端的地址 addr
    client_socket, addr = server_socket.accept()
    with client_socket:
        print(f'连接来自 {addr}')
        data = client_socket.recv(1024).decode('utf-8')
        client_socket.sendall(f'Welcome {addr[0]}'.encode('utf-8'))
        client_socket.close()
```

客户端：

```python
import socket

client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

with client_socket:
    client_socket.connect(('localhost', 10000))
    message = '你的姓名 学号'  # 请替换为实际的姓名和学号
    client_socket.sendall(message.encode('utf-8'))
    response = client_socket.recv(1024).decode('utf-8')
    print(f'收到回复: {response}')
    client_socket.close()
```







## 应用层

### 应用进程通信方式

- 客户/服务器（C/S,Client/Server）方式
- 浏览器/服务器（B/S，Browser/Server）方式
- 对等（P2P，Peer to Peer）方式

服务器的工作方式分为：==循环方式、并发方式==

### 域名系统

- Internet采用层次结构的命名树作为主机的名字，并使用分布式的域名系统（DNS，Domain Name System）
- 名字到域名的解析是由若干个域名服务器程序完成的。域名服务器程序在专设的节点上运行，相应的节点也称为名字服务器(Name Server)或域名服务器(Domain Name Server)

顶级域名、二级域名、三级域名、四级域名...（==没有一级域名！==）

#### 域名服务器

**域名系统的区域**

- ⼀个域名服务器所负责或管辖（有权限的）范围称为管辖区(zone) ， 简称为区
- 各单位根据具体情况来划分自己的管辖区，在⼀个区中的所有节点必须是能够连通的
- 域名服务器的管辖范围以“区”为单位，而不是以“域”为单位
- 管辖区是域名“域”的子集，管辖区可以小于或等于域，但不可能大于域

**权威域名服务器、递归解析器**

当您访问一个网站时，并不会直接向权威域名服务器询。相反，这个过程是由递归解析器代表您的设备完成的。递归解析器通过缓存机制大大减少了重复查询的时间。

权威域名服务器包括：

- 根域名服务器
- 顶级域域名服务器
- 二级域域名服务器
- 三级域域名服务器

三级域及以下的域名服务器(例如nankai.edu.cn)通常在用户本地区域，因此三级域及以下的域名服务器也统称为本地域名服务器

#### 域名解析过程

域名查询有==递归查询==(recursive query)和==迭代查询==(iterative query)两种方式

- 主机向递归解析器/本地域域名服务器的查询⼀般采用递归查询
- 递归解析器/本地域域名服务器向根服务器可以采用递归查询，但⼀般优先采用迭代查询

![DNS](.\img\DNS.png)

### 电子邮件

#### SMTP

简单邮件传输协议SMTP（Simple Mail Transfer  Protocol）

==C/S方式实现，TCP，端口25==

#### POP3

==C/S方式实现，TCP，端口110==

#### IMAP

==C/S方式实现，TCP，端口143==

### 其它应用层协议

#### Telnet

远程登录协议

==C/S方式实现，TCP，端口23==

#### FTP

文件传输协议FTP(File Transfer Protocol)

==C/S方式实现，TCP，端口21==

#### SNMP

==C/S方式实现，UDP==
