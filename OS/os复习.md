# Operating System复习

## 简介

操作系统的五大功能：处理机管理、存储器管理、设备管理、文件管理、作业管理

操作系统的特征：并发、共享、虚拟、异步

虚拟存储管理系统的基础是程序的==局部性理论==

**系统调用**

中断与陷入的主要区别：陷入通常由处理机正在执行的现行指令引起，而中断则是由与现行指令无关的中断源引起的

原语：处于操作系统底层、不可中断执行的操作

1. 用户将系统调用号和所需参数压入堆栈，调用实际的调用指令，执行一个陷入指令，将CPU状态从用户态转为内核态，同时保护中断现场
2. 分析系统调用类型，转入相应的系统调用子程序
3. 在系统调用子程序执行结束后，恢复中断现场，返回被中断的进程或新进程并继续执行





## 进程与线程

### 进程

进程是系统进行资源分配和调度的一个独立单位

进程控制块(Process Control Block, PCB)：由程序段、数据段和PCB构成了进程实体

进程的5个状态：运行态、就绪态、阻塞态、创建态、中止态

**进程的创建** 

1. 申请空白PCB，分配一个唯一的进程标识号
2. 为新进程分配其运行所需的资源
3. 初始化进程控制块PCB
4. 如果进程就绪队列能够接纳新进程，便将进程==插入就绪队列==

**进程的通信**

- 共享存储：对共享空间的读写实现信息交换
- 消息传递：通过发送消息和接受消息两个原语进行数据交换
- 管道通信：管道是一种特殊的共享文件，数据在管道中先进先出，允许两个进程按照生产者-消费者方式进行通信

### 线程

线程是进程中的一个实体，是被系统独立调度和分派的最小单位，自己不拥有系统资源

运行态、就绪态、阻塞态

**进程与线程的区别**

调度、拥有资源、独立性、系统开销登

**线程的实现方式**

- 用户级线程：内核意识不到线程的存在，调度仍然以进程为单位
- 内核级线程：同一进程中的线程切换需要从用户态转到核心态
- 组合方式：包含用户级线程和内核级线程

### CPU调度

**三级调度**

- 高级调度（作业调度）：根据某种算法，决定将外存上处于后备队列的那几个作业调入内存，为他们创建进程、分配必要的资源，并将它们放入就绪队列
- 中级调度（内存调度）：主要功能是提高内存利用率和吞吐量，将暂时不能运行的进程调至外存等待，把外存上已具备运行条件的进程再重新调入内存
- 低级调度（进程调度）：根据某种算法，决定就绪队列中的那几个进程应获得处理机，并由分派程序将处理机分配给被选中的进程

**调度程序**

排队器、分派器、上下文切换器

**进程调度方式**

- 非抢占调度方式：一旦一个进程开始执行，它会一直运行直到自愿放弃CPU
- 抢占调度方式：操作系统可以在任何时候中断当前正在运行的进程，并选择另一个进程来执行

**调度算法**

先来先服务（FCFS, First-Come, First-Served）

- 按照进程到达的顺序依次执行，非抢占式

短作业优先（SJF, Shortest Job First）

- 根据预测的下一个CPU爆发时间选择最短的进程执行

高响应比优先（Highest Response Ratio Next, HRRN）

- 响应比 = (等待时间+预计运行时间) / 预计运行时间

轮转法（Round Robin, RR）

- 每个进程轮流获得一个固定长度的时间片（time slice）来运行，抢占式调度

多级反馈队列调度（Multilevel Feedback Queue Scheduling）

- 使用多个就绪队列，每个队列有自己的优先级和时间片大小，进程可以根据其行为（如是否超时）在不同队列之间移动

### 同步与互斥

**生产者-消费者问题**

一组生产者进程和一组消费者进程共享一个有限缓冲区，生产者负责生成数据并将其放入缓冲区，而消费者则从缓冲区取出数据进行处理

定义如下三个信号量：

- `empty`：表示空闲缓冲槽数量，初始值等于缓冲区的最大容量。
- `full`：表示已填充缓冲槽数量，初始值为0。
- `mutex`：用于保护对缓冲区的访问，确保同一时间只有一个线程能修改缓冲区内容，初始值为1（二进制信号量）。

```pseudocode
// 生产者
while (true) {
    produce_item(item);
    wait(empty);      // 等待有空位
    wait(mutex);      // 进入临界区
    insert_item(buffer, item);
    signal(mutex);    // 离开临界区
    signal(full);     // 增加已填槽数
}

// 消费者
while (true) {
    wait(full);       // 等待有物品
    wait(mutex);      // 进入临界区
    remove_item(buffer, item);
    signal(mutex);    // 离开临界区
    consume_item(item);
    signal(empty);    // 增加空槽数
}
```

**读者-写者问题**

一组读者进程和一组写者进程共享一个资源或数据结构，有两类进程：

1. 读者（Reader）：只读取共享资源的数据，不会对其进行修改。
2. 写者（Writer）：可以读取并修改共享资源的数据。

写者优先（一旦有写者等待，系统就会优先处理写者的请求）的伪代码：

- `mutex`：用于保护对读者计数器`rc`和其他变量的访问，初始值为1。
- `db`：如上所述，控制写者访问。
- `wr`：用于指示是否有写者正在等待，初始值为1。

```pseudocode
int rc = 0; // 记录当前有多少读者正在读取共享资源
semaphore mutex = 1; // 保护对rc的更新操作
semaphore db = 1; // 控制对共享资源的访问权限
semaphore wr = 1; // 保证写者优先,如果有写者在等待，则新的读者不能开始读取

// 读者伪代码
reader() {
    wait(wr); // 确保没有写者在等待
    wait(mutex);
    rc++;
    if (rc == 1) {
        wait(db); // 如果是第一个读者，则锁定写者
    }
    signal(mutex);
    signal(wr);

    // 读取共享资源
    read();

    wait(mutex);
    rc--;
    if (rc == 0) {
        signal(db); // 如果没有读者了，则解锁写者
    }
    signal(mutex);
}

// 写者伪代码
writer() {
    wait(wr); // 阻止更多读者开始
    wait(db); // 锁定所有读者和写者
    // 修改共享资源
    write();
    signal(db);
    signal(wr);
}
```

**哲学家进餐问题**

五个哲学家围坐在一张圆形桌子旁的情景，每个哲学家之间有一根筷子，总共五根。哲学家们交替进行思考和吃饭两种活动，当一个哲学家饥饿时，他必须拿起左右两边的两根筷子才能开始吃饭；吃完后，他会放下筷子继续思考

- 每个哲学家可以处于三种状态之一——思考（thinking）、饥饿（hungry）或者吃饭（eating）

- 一个哲学家只有在拿到左右两边的两根筷子后才能开始吃饭
- 吃完饭后，哲学家会放下手中的筷子并继续思考
- 如果一个哲学家拿起了第一根筷子但无法拿到第二根，那么他应该放回第一根筷子并等待一段时间后再尝试

采用“只有当左右两边的筷子都可用时才允许抓起筷子”的策略：

```pseudocode
semaphore chopstick[5] = {1,1,1,1,1};
semaphore mutex = 1;

Pi{
	while(true){
		wait(mutex);
		wait(chopstick[i]);
		wait(chopstick[(i+1)%5]);
		signal(mutex);
		eat;
		signal(chopstick[i]);
		signal(chopstick[(i+1)%5]);
		think;
	}
}
```

### 死锁

多个进程竞争资源，互相等待对方手里的资源，使得各个进程都被阻塞

**产生死锁的必要条件**

- 互斥条件：进程对所分配到的资源进行排他性使用
- 不可剥夺条件：进程已获得的资源在未使用完之前不能被抢占，只能在进程使用完时释放
- 请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，该资源已被其他进程抢占
- 循环等待条件：在发生死锁时，必然存在一个进程—资源的循环链

**预防死锁**

- 破坏互斥条件，将只能互斥使用的资源改为允许共享使用
- 破坏不可剥夺条件，当一个已保持某些不可抢占资源的进程，提出新的自愿请求而得不到满足时，它必须释放已保持的所有资源
- 破坏请求和保持条件
  - 第一种协议，所有进程在开始运行之前，必须一次性申请其在整个运行过程中所需要的全部资源
  - 第二种协议，允许一个进程只获得运行初期的所需资源后，便开始运行，进程运行过程中再逐步释放已分配给自己的、且已用完的全部资源，然后再请求新的所需资源
- 破坏循环等待条件，对系统所有资源类型进行线性排序并赋予不同编号，每个进程必须按序号递 增的顺序请求资源，若一个已经请求道一些高序号资源的进程又想请求低序号的资源，必须先释放所具 有相同和更高序号的资源后才能申请

**银行家算法**

1. 安全状态：如果存在一种或多种序列，使得按照该序列依次运行每个进程时，它们都能获得所需的资源并最终释放所有已分配的资源，那么这个状态称为“安全状态”。否则，称为“不安全状态”。
2. 资源分配决策：每当一个进程请求资源时，银行家算法会检查此次分配是否会将系统带入不安全状态。如果是，则拒绝此次请求；如果不是，则允许分配资源。
3. 预防死锁：通过确保每次资源分配都保持系统在安全状态下，银行家算法有效地预防了死锁的发生。

为了实现银行家算法，需要维护以下几个数据结构：

- Max[i]：表示进程`i`可能请求的最大资源数量。
- Allocation[i]：表示已经分配给进程`i`的资源数量。
- Need[i] = Max[i] - Allocation[i]：表示进程`i`还需要多少资源才能完成任务。
- Available[]：表示当前系统中可用的资源总数。





## 内存





**四种动态分区算法**

- 首次适应算法FF，每次从链首开始顺序查找，知道找到一个大小能满足要求的空闲分区位置
- 循环首次适应算法NF，每次从上次找到的空闲分区的下一个空闲分区开始查找，知道找到一个大 小能满足要求的空闲分区
- 最佳适应算法BF，每次查找时，总是把能满足要求又是最小的空闲分区分配给作业
- 最坏适应算法WF，每次查找时，总是挑一个最大的空闲区

**页面置换算法**









## I/O

**假脱机**：将一台物理I/O设备虚拟为多台逻辑I/O设备，允许多个用户共享一台物理I/O设备

**假脱机技术** 

假脱机技术”，又称“SPOOLing 技术”，用软件的方式模拟脱机技术。SPOQLing系统的组成如下: 

“输入井”模拟脱机输入时的磁带，用于收容I/o设备输入的数据

“输出井”模拟脱机输出时的磁带，用于收容用户进程输出的数据

“输入进程”模拟脱机输入时的外围控制机

“输出进程”模拟脱机输出时的外围控制机

**抖动**：进程频繁访问的页面数目高于可用的物理块数（分配给进程的物理块不够)

**IO控制的四种方法**

程序直接控制、中断驱动方式、DMA方式、通道控制方式





## 文件与目录













