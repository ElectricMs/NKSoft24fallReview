# 人智导论复习

人智导论复习  202501  2211030

*现在我面临着很尴尬的处境，我只有不到20h来复习这门课程了，或者应该叫预习。*



## 简介

**什么是人工智能？定义？**

示例：研究如何用计算机来表示和执行人类的智能活动

自动控制、科学计算等固定算法的都不算人工智能

**人工智能三大流派**

- 符号主义
- 连接主义
- 行为主义



## 搜索

### 深度优先搜索（DFS)

深度优先搜索是一种尽可能深入每个分支的搜索策略。它从图的起始节点开始，沿着一条路径不断向下探索，直到没有更多未访问的邻接节点为止，然后回溯到前一个节点，继续探索其他分支，直到图中的所有节点都被访问。

==适合寻找最短路径，尤其在无权图中，能够逐层遍历节点，但空间消耗较大。==

#### 工作原理

- 从起始节点开始，首先访问一个节点。
- 然后，选择一个邻接节点进行递归探索，继续沿着该路径向下深入。
- 如果当前节点没有未访问的邻接节点，则回溯到上一节点，继续搜索其它未访问的邻接节点。
- 当所有节点都被访问过时，搜索结束。

#### 特点

- **数据结构**：通常使用栈（可以是递归调用栈或显式的栈）来管理未访问的节点。
- **搜索顺序**：深度优先搜索会先探查一个分支的所有节点，然后才会回到父节点进行其他分支的搜索。
- 适用场景：
  - 适用于需要查找每一条路径或寻找图中的所有可能路径的问题。
  - 适合用于求解连通性、拓扑排序等问题。
  - 适用于空间资源有限的情况，尤其是在路径较长时，因为它较少需要存储未探索节点。

#### 时间复杂度

- 对于图中的每个节点和边都访问一次，时间复杂度为 O(V+E)O(V + E)，其中 VV 是节点数，EE 是边数。

#### 缺点

- 深度优先搜索可能会陷入无限循环，尤其是在图中存在环的情况下（如果没有标记已访问节点，则容易重复访问）。
- 在某些情况下，深度优先搜索可能会找到非最优解，特别是在寻找最短路径的情况下。

#### 示例

假设图如下：

```
    A
   / \
  B   C
 / \
D   E
```

DFS的遍历顺序可能是：A → B → D → E → C。



### 宽度优先搜索（BFS）

宽度优先搜索是一种逐层遍历节点的策略。它从图的起始节点开始，首先访问所有与起始节点直接相连的节点，然后再访问这些节点的邻接节点，依此类推，逐层扩展。

==适合探索每一条路径，尤其在空间有限的情况下，能够快速找到解，但可能不总是最优解。==

#### 工作原理

- 从起始节点开始，将其加入到队列中。
- 从队列中取出一个节点，访问它的所有邻接节点。
- 对于每一个邻接节点，如果尚未访问，则将它加入队列。
- 继续从队列中取出下一个节点，直到队列为空。

#### 特点

- **数据结构**：通常使用队列（FIFO）来管理待访问的节点。
- **搜索顺序**：宽度优先搜索会首先遍历起始节点的所有邻接节点，然后再依次遍历它们的邻接节点，即按层次逐层访问。
- 适用场景：
  - BFS能够找到最短路径，特别是在无权图中寻找从起点到目标的最短路径时非常有效。
  - 适用于寻找图中的最短路径、最小生成树等问题。

#### 时间复杂度

- 对于图中的每个节点和边都访问一次，时间复杂度为 O(V+E)O(V + E)，其中 VV 是节点数，EE 是边数。

#### 缺点

- BFS需要存储所有当前层次的节点，可能会消耗较多内存，尤其是在图很大的时候。
- BFS在某些情况下可能不适用于图的深度过大的场景，因为需要维护一个较大的队列。

#### 示例

假设图如下：

```
    A
   / \
  B   C
 / \
D   E
```

BFS的遍历顺序可能是：A → B → C → D → E。



### A*搜索

A*（A-star）搜索算法是一种广泛使用的启发式搜索算法，特别适用于路径规划问题，如在图形中找到从起点到目标点的最短路径。它结合了**最佳优先搜索**和**Dijkstra算法**的优点，能够高效地找到最优路径。

A\*算法通过使用启发式函数（heuristic function）来优化搜索过程。它在每一步都选择一个估计总成本最小的节点来扩展，从而加速搜索过程。具体来说，A*算法评估每个节点的总代价 f(n)，其中：

f(n)=g(n)+h(n)

- **g(n)**：从起点到节点 n 的实际成本（即路径长度或移动代价）。
- **h(n)**：从节点 n 到目标的启发式估计成本（即预测的剩余路径成本）。

A*搜索通过综合考虑已走过的路径成本 g(n) 和到目标的估计成本 h(n)，以此来选择最有希望的路径。

#### 算法步骤

1. **初始化**：将起点添加到开放列表（open list）中，开放列表用于存储待检查的节点。每个节点都包含其坐标、成本值和父节点信息。
2. **循环迭代**：
   - 从开放列表中选择具有最小 f(n) 值的节点进行扩展。
   - 对于当前节点的每个相邻节点，计算其 g(n)、h(n) 和 f(n) 值。
   - 如果相邻节点不在开放列表中，将其加入开放列表；如果它已经在开放列表中，并且新路径更优（即 g(n) 更小），则更新它的值。
   - 当一个节点的扩展失败（即所有邻接节点都被访问或不可行），搜索将回溯到该节点的父节点，继续探索其他未探索的路径。
3. **结束条件**：
   - 如果目标节点被添加到闭合列表（closed list）中，或是选择的节点就是目标节点，则搜索结束，返回路径。
   - 如果开放列表为空，说明没有找到路径，搜索失败。

#### 启发式函数 h(n)

启发式函数的选择直接影响算法的效率和准确性。常见的启发式函数有：

- **曼哈顿距离（Manhattan Distance）**：适用于网格上只有上下左右方向移动的情况，计算节点与目标点在水平和垂直方向上的总距离。

  h(n)=∣x1−x2∣+∣y1−y2∣h(n) = |x_1 - x_2| + |y_1 - y_2|

- **欧几里得距离（Euclidean Distance）**：适用于可以任意方向移动的情况，计算节点与目标点的直线距离。

  h(n)=(x1−x2)2+(y1−y2)2h(n) = \sqrt{(x_1 - x_2)^2 + (y_1 - y_2)^2}

- **切比雪夫距离（Chebyshev Distance）**：适用于可以在八个方向上移动的情况，计算节点与目标点的最大横纵向距离。

  h(n)=max⁡(∣x1−x2∣,∣y1−y2∣)h(n) = \max(|x_1 - x_2|, |y_1 - y_2|)

#### 优缺点

**优点**：

- 能够找到最短路径（如果启发式函数是可接受的，即不会过于乐观）。
- 具有较高的效率，尤其是在大规模搜索空间中，通过启发式函数减少了不必要的搜索。

**缺点**：

- 需要大量的内存，因为开放列表和闭合列表都需要存储大量节点。
- 启发式函数的设计对算法的性能和效率有很大影响，选择不当可能导致性能低下。





## 博弈论

**博弈六特征**

- 2 或多玩家
- 轮流vs.同时
- 完整信息vs.不完整信息
- 确定的vs.随机的
- 合作vs.竞争
- 零和vs.非零和

**零和博弈**

一方的收益必然意味着另一方的损失，博弈各方的收益和损失相加的总和永远为0

**纳什均衡**

若任何参与者单独改变策略都不会得到好处，则该情形下的策略组合就是⼀个纳什均衡

例：囚徒困境两人都选择交代罪行

### Minimax算法

在Minimax搜索中，我们从根节点开始递归地搜索整个博弈树。每次递归调用会展开一个游戏状态，计算该状态下的最优得分，直到达到树的叶节点。

1. **Max玩家**（Max层）：选择使得自己的得分最大化的分支。
2. **Min玩家**（Min层）：选择使得Max玩家的得分最小化的分支。

最终，当递归回溯到根节点时，Max玩家会选择得分最大的路径，从而确保自己获得最优的策略。



### α-β剪枝

**基本思想**

在对抗搜索中：

- **α** 是当前已经发现的 **Max 层的最佳值**（最大值的下界）。
- **β** 是当前已经发现的 **Min 层的最佳值**（最小值的上界）。

如果某个分支的值已经确定不会影响最终决策，则可以提前停止对该分支的搜索（剪枝），避免浪费计算资源。

**剪枝条件**

- 对于 **Max 层**，如果某个子节点的值 ≥ 当前 **β**，则不需要继续搜索该节点的其他子分支，因为 Min 玩家不会选择导致 Max 玩家得分更高的路径。
- 对于 **Min 层**，如果某个子节点的值 ≤ 当前 **α**，则不需要继续搜索该节点的其他子分支，因为 Max 玩家不会选择导致自己得分更低的路径。



### 蒙特卡洛树搜索（MCTS）









## 归结原理

- 将待证明公式转换为**合取范式 (CNF)**，即所有公式都表示为子句的合取形式。
- 将待证明公式的否定与已知条件一起构成一个子句集。
- 对子句集中任意两个子句应用**归结规则**，生成新的子句。
- 将新子句加入子句集中，重复这一过程，直到产生矛盾（空子句）或无新子句可生成。
